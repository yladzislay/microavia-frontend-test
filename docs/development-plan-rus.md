# План Разработки Алгоритма Генерации Параллельных Линий (версия 3)

Этот документ описывает этапы разработки алгоритма `createParallelHatching`, учитывая полный контекст структуры проекта, данных и актуальный способ вызова функции.

## 0. Подготовительный этап и Настройка

-   [ ] **0.1. Уточнение работы с параметрами функции `createParallelHatching`**:
    -   **Сигнатура функции (остается без изменений)** в `src/lines/parallelHatchingAlgorithm.ts`:
        ```typescript
        export function createParallelHatching(
            coordinates: [number, number, number?][][], // Принимает массив колец [[lon, lat, alt?], ...]
            step: number = 100,
            bearing: number = 0,
            offset: number = 50
        ): LonLat[][] // Возвращает массив линий, каждая линия [[startLon, startLat], [endLon, endLat]] в формате LonLat
        ```
    -   **Использование параметров внутри функции**:
        -   Входящий `coordinates` — это `polygon.coordinates` (массив колец). Для работы с внешним контуром полигона (согласно требованиям "без отверстий") внутри функции необходимо использовать `coordinates[0]`.
        -   Параметры `step`, `bearing`, `offset` будут использоваться со значениями по умолчанию, так как текущий вызов в `src/main.ts` (`createParallelHatching(coordinates)`) не передает их явно. Это соответствует требованию о значениях по умолчанию.
    -   **Контрольная точка**: Убедиться, что `polygon.coordinates[0]` корректно извлекается и представляет собой массив точек `[[lon, lat, alt?], ...]`.

-   [ ] **0.2. Глубокое изучение инструментов OpenGlobus (Ellipsoid)**:
    -   [ ] Изучить класс `Ellipsoid` из `@openglobus/og`. Он будет основным для геодезических расчетов.
        -   `GLOBUS.planet.ellipsoid` – доступный экземпляр.
        -   Метод `ellipsoid.inverse(lonLat1: LonLat, lonLat2: LonLat)`: для вычисления расстояния и начального/конечного азимутов между двумя точками `LonLat`.
        -   Метод `ellipsoid.direct(lonLat: LonLat, distance: number, initialBearing: number, finalBearing?: number)`: для вычисления конечной точки `LonLat` по начальной точке, расстоянию (в метрах) и начальному азимуту (в градусах).
    -   [ ] Уточнить единицы измерения углов (градусы vs радианы) для азимутов в методах `Ellipsoid`. Входной параметр `bearing` для нашей функции задан в градусах.
    -   [ ] Понять, как создавать экземпляры `LonLat` из массивов `[longitude, latitude, altitude?]`.

## 1. Базовая обработка входных данных и вспомогательные функции

-   [ ] **1.1. Конвертация координат полигона**:
    -   [ ] Внутри `createParallelHatching`, получить внешний контур полигона: `const outerRingCoordinates = coordinates[0];`.
    -   [ ] Преобразовать `outerRingCoordinates` (который `[number, number, number?][]`) в массив экземпляров `LonLat[]`. Высоту можно игнорировать для 2D расчетов.
-   [ ] **1.2. Вспомогательные математические и геодезические утилиты**:
    -   [ ] Функция для перевода градусов в радианы и обратно (если API OpenGlobus требует радианы для каких-то расчетов углов).
    -   [ ] Функция для нормализации азимута (например, приведение к диапазону 0-360 градусов).
    -   [ ] Функция для вычисления перпендикулярного азимута к заданному `bearing`. (bearing ± 90 градусов).

## 2. Определение рабочей области для генерации линий

-   [ ] **2.1. Нахождение охватывающего прямоугольника (Bounding Box) полигона**:
    -   [ ] Вычислить минимальные и максимальные значения широты и долготы для вершин полигона (используя `LonLat[]` из п.1.1). Это даст представление о его габаритах.
-   [ ] **2.2. Определение "коридора" для линий**:
    -   [ ] "Повернуть" полигон мысленно так, чтобы заданный `bearing` стал основным направлением (например, вертикальным).
    -   [ ] Спроектировать все вершины полигона на линию, перпендикулярную `bearing`.
    -   [ ] Найти минимальное и максимальное смещение вершин вдоль этой перпендикулярной линии относительно некоторой опорной точки. Это определит ширину "коридора", который должен быть покрыт линиями.
    -   [ ] Определить начальную точку для первой линии в этом "коридоре".

## 3. Генерация "бесконечных" параллельных линий

-   [ ] **3.1. Определение параметров первой "бесконечной" линии**:
    -   [ ] Используя результаты из п.2.2, создать первую линию. Она должна быть достаточно длинной, чтобы пересечь весь охватывающий прямоугольник полигона (с учетом будущего `offset`). Начальная и конечная точки этой линии должны лежать за пределами BBox полигона.
-   [ ] **3.2. Генерация последующих "бесконечных" линий**:
    -   [ ] Последовательно генерировать другие "бесконечные" линии. Каждая следующая линия смещается относительно предыдущей на расстояние `step` в направлении, перпендикулярном `bearing`.
    -   [ ] Продолжать генерацию, пока линии покрывают весь "коридор", определенный в п.2.2.

## 4. Отсечение ("кЛиппинг") линий по полигону

-   [ ] **4.1. Алгоритм пересечения отрезка и ребра полигона**:
    -   [ ] Реализовать или найти готовую функцию, определяющую точку пересечения двух геодезических отрезков (сегментов).
-   [ ] **4.2. Поиск точек пересечения для каждой "бесконечной" линии**:
    -   [ ] Для каждой сгенерированной "бесконечной" линии найти все точки ее пересечения с ребрами полигона (отрезками, образованными парами соседних вершин `LonLat` из п.1.1).
    -   [ ] Отсортировать найденные точки пересечения вдоль каждой "бесконечной" линии.
-   [ ] **4.3. Формирование внутренних отрезков**:
    -   [ ] На основе отсортированных точек пересечения сформировать отрезки, которые лежат внутри полигона. Для простого полигона каждая линия будет давать четное число пересечений (вход-выход, вход-выход...). Нас интересуют пары (1-2, 3-4 и т.д.).

## 5. Применение отступа (`offset`)

-   [ ] **5.1. Удлинение внутренних отрезков**:
    -   [ ] Для каждого внутреннего отрезка, полученного на этапе 4.3 (представленного двумя точками `LonLat`):
        -   Удлинить его начальную точку "назад" (против направления `bearing`) на расстояние `offset`.
        -   Удлинить его конечную точку "вперед" (вдоль направления `bearing`) на расстояние `offset`.
        -   Использовать `ellipsoid.direct()` для вычисления новых координат этих удлиненных точек.
    -   [ ] Собрать все полученные удлиненные отрезки (каждый как пара `[startLonLat, endLonLat]`) в итоговый массив `LonLat[][]`.

## 6. Тестирование и Отладка

-   [ ] **6.1. Начальное тестирование с простыми данными**:
    -   [ ] Подготовить простой тестовый полигон (например, квадрат или прямоугольник) и проверить базовую логику.
    -   [ ] Использовать `console.log` и отладчик для проверки промежуточных результатов.
-   [ ] **6.2. Визуальное тестирование на сцене**:
    -   [ ] Использовать предоставленную сцену OpenGlobus для проверки корректности отрисовки линий для различных полигонов из `polygons.json`.
    -   [ ] Проверить поведение при значениях `step`, `bearing`, `offset` по умолчанию. (Для тестирования других значений потребуется модификация `main.ts` или реализация UI).
    -   [ ] Сравнить результат с эталонным видео.
    -   [ ] Использовать встроенный инструмент "линейка" для проверки расстояний между линиями (`step`) и отступов от краев полигона (`offset`).
-   [ ] **6.3. Тестирование краевых случаев**:
    -   [ ] Полигоны сложной, вогнутой формы.
    -   [ ] Маленькие полигоны (меньше `step` или `offset`).
    -   [ ] Нулевые значения `step`.
    -   [ ] Экстремальные значения `bearing` (0, 90, 180, 270, 360, а также промежуточные).

## 7. Оптимизация (при необходимости)

-   [ ] **7.1. Профилирование производительности**:
    -   [ ] Оценить время выполнения алгоритма для больших и сложных полигонов.
-   [ ] **7.2. Поиск узких мест и оптимизация**:
    -   [ ] Оптимизировать вычисления пересечений (например, сначала проверять пересечение с BBox полигона).
    -   [ ] Минимизировать количество дорогостоящих геодезических вычислений.
    -   [ ] Рассмотреть использование пространственных индексов для ускорения поиска пересечений с ребрами полигона (если стандартный перебор будет слишком медленным для очень больших полигонов).

## 8. Реализация опциональных требований (UI-виджет)

-   [ ] **8.1. Проектирование UI-виджета**:
    -   [ ] Определить состав элементов: input для `step`, `bearing`, `offset`. Возможно, кнопка "Применить" или автоматическое обновление.
-   [ ] **8.2. Добавление HTML-разметки для виджета**:
    -   [ ] Разместить элементы на странице (например, в `index.html` или динамически создать).
-   [ ] **8.3. Реализация логики UI**:
    -   [ ] Написать TypeScript/JavaScript для считывания значений из полей виджета.
    -   [ ] При изменении значений в виджете, **модифицировать вызов `createParallelHatching` в `main.ts`**, чтобы передавать считанные `step`, `bearing`, `offset` как дополнительные аргументы.
    -   [ ] Обеспечить перерисовку линий на карте.
    -   [ ] Добавить валидацию вводимых значений (например, `step` и `offset` не должны быть отрицательными).

## 9. Финализация и Сдача проекта

-   [ ] **9.1. Рефакторинг и чистка кода**:
    -   [ ] Удалить отладочный код (`console.log` и т.п.).
    -   [ ] Улучшить читаемость, добавить комментарии, где это необходимо.
    -   [ ] Проверить соответствие стайлгайдам, если они есть.
-   [ ] **9.2. Финальная проверка по списку требований**:
    -   [ ] Пройтись по файлу `docs/requirements-rus.md` и отметить выполненные пункты.
-   [ ] **9.3. Подготовка решения к отправке**:
    -   [ ] Подготовить форк CodeSandbox или архив проекта согласно инструкции.
    -   [ ] Написать краткое описание принятых решений или сложностей, если это требуется.

---
Этот план будет служить основой для нашей работы. Мы можем детализировать каждый этап по мере продвижения.
```