## Алгоритм генерации параллельной штриховки: Повествовательное изложение

Наш алгоритм предназначен для создания набора параллельных линий (штриховки) внутри заданной многоугольной области (полигона). Эти линии должны быть ориентированы под определенным углом, находиться на заданном расстоянии друг от друга и иметь внешний отступ от краев полигона.

Процесс можно разбить на следующие ключевые этапы:

**Этап 1: Подготовка сцены и актеров (Функция `preparePolygon`)**

1.  **Принимаем данные:** На вход поступают координаты вершин полигона и параметры штриховки: шаг между линиями (`step`), угол ориентации (`bearing`) и внешний отступ (`offset`).
2.  **Замыкаем полигон:** Убеждаемся, что наш полигон является замкнутой фигурой, соединяя первую и последнюю точки, если они еще не соединены. Это стандартное требование для многих геометрических операций.
3.  **Создаем цифрового двойника полигона:** Преобразуем массив координат в стандартный GeoJSON-объект типа "Polygon". Это позволяет нам использовать мощные инструменты библиотеки Turf.js.
4.  **Находим центр тяжести:** Вычисляем центроид нашего полигона. Эта точка будет служить осью для последующих вращений, обеспечивая предсказуемое поведение.
5.  **Нормализуем угол:** Приводим заданный угол `bearing` к диапазону от 0 до 180 градусов. Это упрощает дальнейшие расчеты, так как линии, повернутые, например, на 270 градусов, эквивалентны линиям, повернутым на 90 градусов.
6.  **Временный поворот для удобства:** Мысленно (а на самом деле программно) поворачиваем наш полигон вокруг его центра на угол, обратный нормализованному `bearing`. В результате этого преобразования полигон оказывается ориентирован так, как если бы требуемые линии штриховки были строго горизонтальными. Это значительно упрощает генерацию "кандидатов" для наших будущих линий.

**Этап 2: Чертим черновики линий (Функция `generateParentLines`)**

1.  **Определяем рабочую зону:** На основе повернутого на предыдущем шаге полигона мы вычисляем его габаритный прямоугольник (bounding box). Затем, чтобы гарантированно покрыть всю необходимую область с учетом будущих отступов и шага, мы немного расширяем эту зону во все стороны.
2.  **Рисуем длинные горизонтальные "заготовки":** В этой расширенной рабочей зоне мы начинаем "рисовать" очень длинные горизонтальные линии.
    *   Первая такая линия проводится чуть ниже самой южной точки нашего повернутого полигона (с учетом необходимого запаса).
    *   Каждая последующая линия рисуется выше предыдущей на расстоянии, равном заданному `step` (шагу штриховки).
    *   Этот процесс продолжается до тех пор, пока мы не выйдем за верхнюю границу нашей расширенной рабочей зоны (то есть, покроем область выше самой северной точки повернутого полигона с запасом).
    *   Длина этих "заготовок" выбирается такой, чтобы они заведомо пересекали всю ширину повернутого полигона, даже с учетом его возможных выступов.
    *   Для безопасности, чтобы избежать бесконечных циклов (например, при очень малом шаге или проблемах с точностью вычислений), мы ограничиваем максимальное количество генерируемых линий-заготовок.

**Этап 3: Обрезка по контуру (Функция `clipLinesByPolygon`)**

1.  **Наложение трафарета:** Теперь мы берем каждую из наших длинных горизонтальных "заготовок" и "накладываем" на нее трафарет в виде нашего повернутого полигона.
2.  **Вырезаем нужные части:** С помощью функции `turf.intersect` мы находим те части каждой "заготовки", которые оказались внутри полигона-трафарета. Результатом этой операции являются отрезки линий, точно лежащие внутри повернутого полигона. Если линия-заготовка не пересекает полигон, она отбрасывается. Если пересекает несколько раз (для сложных, невыпуклых полигонов), мы получаем несколько отрезков.
3.  **Собираем урожай:** Все полученные таким образом "чистые" отрезки, находящиеся внутри полигона, мы собираем в новый список.

**Этап 4: Добавляем поля (Функция `applyOffsetToLines`)**

1.  **Проверяем необходимость:** Если заданный внешний отступ `offset` равен нулю, этот этап пропускается.
2.  **Удлиняем каждый отрезок:** Для каждого "чистого" отрезка, полученного на предыдущем этапе:
    *   Определяем его направление (азимут).
    *   Смещаем его начальную точку "назад" (против направления линии) на величину `offset`.
    *   Смещаем его конечную точку "вперед" (по направлению линии) на величину `offset`.
    *   Таким образом, каждый отрезок удлиняется с обеих сторон, создавая эффект внешнего отступа от исходных границ полигона.

**Этап 5: Возвращение в исходное положение (Функция `rotateLines`)**

1.  **Отменяем временный поворот:** Все наши отрезки (теперь уже с примененным отступом) были созданы в системе координат, где полигон был "выровнен" горизонтально. Теперь мы поворачиваем каждый из этих отрезков обратно на исходный угол `actualBearing` (который мы нормализовали на Этапе 1). Вращение происходит вокруг того же центра полигона, который использовался на Этапе 1.
2.  **Результат:** После этого обратного поворота все наши линии оказываются ориентированы под требуемым углом `bearing` относительно Севера, как и было задумано.

**Этап 6: Финальное оформление (Функция `formatResult`)**

1.  **Приводим к нужному формату:** На этом заключительном этапе мы преобразуем наши линии из внутреннего формата GeoJSON (используемого библиотекой Turf.js) в простой массив массивов координат, как того требует спецификация выходных данных задачи. Каждая линия представляется массивом из двух точек, а каждая точка – массивом из двух чисел (долгота, широта).

**Итог:**

В результате выполнения всех этих шагов мы получаем набор параллельных линий, аккуратно вписанных (или выходящих за пределы с учетом `offset`) в исходный полигон, ориентированных под нужным углом и расположенных на заданном расстоянии друг от друга. Алгоритм старается быть надежным, используя проверенные функции библиотеки Turf.js для сложных геометрических вычислений, и при этом разбит на логические части для лучшего понимания и сопровождения.