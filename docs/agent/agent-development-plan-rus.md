# План разработки: Алгоритм параллельной штриховки (Версия без UI)

**Цель:** Реализовать ядро алгоритма генерации параллельной штриховки для полигона. Функция `createParallelHatching` должна корректно работать и возвращать массив линий в соответствии с предоставленной ранее логикой и структурой файлов.

**Используемые технологии:** TypeScript, Turf.js.

---

## Этап 1: Настройка структуры проекта и типов

-   [ ] **Задача 1.1:** Создать структуру директорий:
    -   `src/services/parallel-hatch-generator/`
-   [ ] **Задача 1.2:** Внутри `src/services/parallel-hatch-generator/` создать файл `types.ts`.
    -   [ ] Скопировать или определить следующие типы: `LngLat`, `PolygonCoordinates`, `LineStringCoordinates`, `HatchingLines`, `HatchingOptions`, `GeoJsonPolygon`, `GeoJsonPoint`, `GeoJsonLineString`.
    ```typescript
    // Содержимое для types.ts (ссылка на ранее предоставленный код)
    // import { Feature, Point, Polygon, LineString } from '@turf/turf';
    //
    // export type LngLat = [number, number];
    // export type PolygonCoordinates = LngLat[];
    // // ... и т.д.
    ```
-   [ ] **Задача 1.3:** Создать пустые `.ts` файлы для каждой функции сервиса в директории `src/services/parallel-hatch-generator/`:
    -   [ ] `preparePolygon.ts`
    -   [ ] `generateParentLines.ts`
    -   [ ] `clipLinesByPolygon.ts`
    -   [ ] `applyOffsetToLines.ts`
    -   [ ] `rotateLines.ts`
    -   [ ] `formatResult.ts`
    -   [ ] `index.ts` (для экспорта `createParallelHatchingService`)
-   [ ] **Задача 1.4:** Убедиться, что библиотека `@turf/turf` установлена в проекте (проверить `package.json` или выполнить `npm install @turf/turf`).

---

## Этап 2: Реализация функций сервиса `parallel-hatch-generator`

Для каждой функции ниже: скопировать предоставленный ранее код, убедиться в корректности импортов (включая `@turf/turf` и локальные типы/модули).

-   [ ] **Задача 2.1: Реализация `preparePolygon.ts`**
    -   [ ] Реализовать функцию `preparePolygon`.
    -   [ ] Обеспечить корректный экспорт функции.
-   [ ] **Задача 2.2: Реализация `generateParentLines.ts`**
    -   [ ] Реализовать функцию `generateParentLines` (используя последнюю версию с уточненными расчетами запасов и `extraPaddingMeters`, которое можно пока захардкодить или передать как `step * 2`).
    -   [ ] Обеспечить корректный экспорт функции.
-   [ ] **Задача 2.3: Реализация `clipLinesByPolygon.ts`**
    -   [ ] Реализовать функцию `clipLinesByPolygon` (включая обработку `GeometryCollection` из `turf.intersect`).
    -   [ ] Обеспечить корректный экспорт функции.
-   [ ] **Задача 2.4: Реализация `applyOffsetToLines.ts`**
    -   [ ] Реализовать функцию `applyOffsetToLines`.
    -   [ ] Обеспечить корректный экспорт функции.
-   [ ] **Задача 2.5: Реализация `rotateLines.ts`**
    -   [ ] Реализовать функцию `rotateLines`.
    -   [ ] Обеспечить корректный экспорт функции.
-   [ ] **Задача 2.6: Реализация `formatResult.ts`**
    -   [ ] Реализовать функцию `formatResult`.
    -   [ ] Обеспечить корректный экспорт функции.

---

## Этап 3: Реализация основного сервисного метода и точки входа

-   [ ] **Задача 3.1: Реализация `index.ts` (сервис `createParallelHatchingService`)**
    -   [ ] В файле `src/services/parallel-hatch-generator/index.ts` реализовать функцию `createParallelHatchingService`.
    -   [ ] Импортировать все необходимые функции из файлов, созданных на Этапе 2.
    -   [ ] Реализовать логику вызова этих функций в правильной последовательности, как было описано в "повествовании алгоритма".
    -   [ ] Обеспечить корректный экспорт `createParallelHatchingService`.
-   [ ] **Задача 3.2: Реализация `createParallelHatching` (точка входа из `src/lines/parallelHatchingAlgorithm.ts`)**
    -   [ ] Открыть или создать файл `src/lines/parallelHatchingAlgorithm.ts`.
    -   [ ] Реализовать функцию `createParallelHatching(polygon: number[][], step: number, bearing: number, offset: number): number[][][]`.
    -   [ ] Импортировать `createParallelHatchingService` из `src/services/parallel-hatch-generator/index.ts`.
    -   [ ] Импортировать необходимые типы (`PolygonCoordinates`, `HatchingOptions` из `types.ts` сервиса) для приведения типов входных параметров, если это необходимо для строгой типизации.
    -   [ ] Внутри функции `createParallelHatching` вызвать `createParallelHatchingService`, передав ей параметры.
    -   [ ] Вернуть результат вызова `createParallelHatchingService`.

---

## Этап 4: Базовое тестирование и отладка (без UI)

-   [ ] **Задача 4.1: Подготовка тестовых данных**
    -   Создать (можно в отдельном временном файле или закомментировать в `main.ts`) несколько наборов тестовых данных для полигонов и опций:
        *   Простой квадрат: `[[0,0], [0,10], [10,10], [10,0], [0,0]]`, `step: 2`, `bearing: 0`, `offset: 0`.
        *   Тот же квадрат, `bearing: 45`.
        *   Тот же квадрат, `offset: 1`.
        *   (Опционально) Более сложный полигон (например, L-образный или вогнутый).
-   [ ] **Задача 4.2: Запуск и проверка результатов**
    -   Вызвать реализованную функцию `createParallelHatching` с тестовыми данными.
    -   Вывести результат (массив линий) в консоль: `console.log(JSON.stringify(resultLines));`.
    -   **Проанализировать вывод:** Убедиться, что:
        *   Количество линий примерно соответствует ожиданиям.
        *   Координаты линий выглядят правдоподобно.
        *   Нет очевидных ошибок или пустых результатов там, где они не ожидаются.
-   [ ] **Задача 4.3: Отладка (при необходимости)**
    -   Если возникают ошибки или неожиданные результаты, использовать `console.log` внутри функций сервиса (`preparePolygon`, `generateParentLines` и т.д.) для вывода промежуточных результатов и отладки логики.
    -   Обратить внимание на сообщения `console.warn` из кода (например, `safetyBreak triggered`).

---

**Заметки для AI-Агента:**

*   Пожалуйста, следуй этому плану поэтапно.
*   Уделяй внимание корректности импортов/экспортов между модулями.
*   Код для каждой функции был предоставлен ранее в нашем обсуждении. Используй его как основу.
*   Если возникают неясности или ошибки TypeScript, которые сложно разрешить, отметь это.
*   Основная цель этого этапа – получить работающее ядро алгоритма. Визуальная часть будет добавлена позже.